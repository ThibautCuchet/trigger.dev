---
title: "Generate a thumbnail from a video using FFmpeg"
sidebarTitle: "Generate thumbnail with FFmpeg"
description: "This example shows you how to generate a thumbnail from a video using FFmpeg with Trigger.dev."
---

## Overview

This task uses FFmpeg to generate a thumbnail from a video at a specific time point.

## Key Features:

- Fetches a video from a given URL
-     Generates a thumbnail from the video at the 50% time point
- Sets the thumbnail size to 320x240 pixels
- Handles temporary file management by creating and cleaning up input and output files
- Returns the generated thumbnail buffer, the file path of the thumbnail, the original video size, and the thumbnail size

## Task code

````ts trigger/ffmpeg-extract-audio.ts

```ts trigger/ffmpeg-compress-video.ts
import fetch from "node-fetch";
import fs from "fs/promises";
import path from "path";
import { logger, task } from "@trigger.dev/sdk/v3";
import ffmpeg from "fluent-ffmpeg";

export const ffmpegCompressVideo = task({
  id: "ffmpeg-compress-video",
  run: async (payload: { videoUrl: string }, { ctx }) => {
    if (ctx.environment.type !== "DEVELOPMENT") {
      ffmpeg.setFfmpegPath("/usr/bin/ffmpeg");
      ffmpeg.setFfprobePath("/usr/bin/ffprobe");
    }
    const { videoUrl } = payload;

    // Generate temporary file names
    const tempInputPath = path.join("/tmp", `input_${Date.now()}.mp4`);
    const outputPath = path.join("/tmp", `output_${Date.now()}.mp4`);

    try {
      // Fetch the video
      const response = await fetch(videoUrl);
      const buffer = await response.buffer();
      await fs.writeFile(tempInputPath, buffer);

      // Compress the video
      await new Promise((resolve, reject) => {
        ffmpeg(tempInputPath)
          .outputOptions([
            "-c:v libx264", // Use H.264 codec
            "-crf 28", // Higher CRF for more compression (28 is near the upper limit for acceptable quality)
            "-preset veryslow", // Slowest preset for best compression
            "-vf scale=iw/2:ih/2", // Reduce resolution to 320p width (height auto-calculated)
            "-c:a aac", // Use AAC for audio
            "-b:a 64k", // Reduce audio bitrate to 64k
            "-ac 1", // Convert to mono audio
          ])
          .output(outputPath)
          .on("end", resolve)
          .on("error", reject)
          .run();
      });

      // Read the compressed video
      const compressedVideo = await fs.readFile(outputPath);

      // Get file sizes for comparison
      const originalSize = buffer.length;
      const compressedSize = compressedVideo.length;

      // Clean up temporary files
      await fs.unlink(tempInputPath);

      // Log compression results
      logger.log(`Original video size: ${originalSize} bytes`);
      logger.log(`Compressed video size: ${compressedSize} bytes`);
      logger.log(`Compression ratio: ${((1 - compressedSize / originalSize) * 100).toFixed(2)}%`);
      logger.log(`Compressed video saved at: ${outputPath}`);

      // Return the compressed video buffer, file path, and compression stats
      return {
        compressedVideoBuffer: compressedVideo,
        compressedVideoPath: outputPath,
        originalSize,
        compressedSize,
        compressionRatio: ((1 - compressedSize / originalSize) * 100).toFixed(2),
      };
    } catch (error) {
      logger.error("Error compressing video:", { error });
      // Clean up files in case of error
      try {
        await fs.unlink(tempInputPath);
        await fs.unlink(outputPath);
      } catch (cleanupError) {
        logger.error("Error during cleanup:", { cleanupError });
      }
      throw error;
    }
  },
});
````
